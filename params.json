{"name":"ruby-qml","tagline":"A QML / Qt Quick bindings for Ruby","body":"ruby-qml [![Gem Version](https://badge.fury.io/rb/qml.svg)](http://badge.fury.io/rb/qml)\r\n================\r\n\r\nruby-qml is a QML / Qt Quick wrapper for Ruby.\r\nIt provides bindings between QML and Ruby and enables you to use Qt Quick-based GUI from Ruby.\r\n\r\n* [Documentation](http://rubydoc.info/github/seanchas116/ruby-qml/master/frames)\r\n* [Examples](https://github.com/seanchas116/ruby-qml/tree/master/examples)\r\n\r\n[![Dependency Status](https://gemnasium.com/seanchas116/ruby-qml.svg)](https://gemnasium.com/seanchas116/ruby-qml)\r\n[![Build Status](https://travis-ci.org/seanchas116/ruby-qml.svg?branch=master)](https://travis-ci.org/seanchas116/ruby-qml)\r\n[![Coverage Status](https://coveralls.io/repos/seanchas116/ruby-qml/badge.png?branch=master)](https://coveralls.io/r/seanchas116/ruby-qml?branch=master)\r\n[![Inline docs](http://inch-ci.org/github/seanchas116/ruby-qml.png?branch=master)](http://inch-ci.org/github/seanchas116/ruby-qml)\r\n\r\n## What you can do with ruby-qml\r\n\r\n* Develop desktop GUI applications only with Ruby and QML\r\n* Easily combine codes written in C++ and Qt with your Ruby code\r\n\r\n## Gallery\r\n\r\n[![Screenshot](https://raw.github.com/seanchas116/ruby-qml/master/examples/todo_sequel/capture.png)](https://github.com/seanchas116/ruby-qml/tree/master/examples/todo_sequel)\r\n\r\n[![Screenshot](https://raw.github.com/seanchas116/ruby-qml/master/examples/twitter/capture.png)](https://github.com/seanchas116/ruby-qml/tree/master/examples/twitter)\r\n\r\n## Installation\r\n\r\nruby-qml requires **Ruby 1.9 or later** and currently supports **OS X** and **Linux**.\r\n\r\n### OS X with Homebrew\r\n\r\nRun the following commands to install ruby-qml on OS X with Homebrew:\r\n\r\n    $ brew install pkg-config\r\n    $ brew install libffi\r\n    $ brew install qt5\r\n    $ gem install qml -- --with-libffi-dir=$(brew --prefix libffi) --with-qt-dir=$(brew --prefix qt5)\r\n\r\n### General (OSX and Linux)\r\n\r\n#### Requirements\r\n\r\n* pkg-config\r\n* libffi\r\n* Qt 5.2 or later\r\n\r\nTo install, use this command after installing requirements:\r\n\r\n    $ gem install qml\r\n\r\n### Use Gemfile\r\n\r\nAdd this line to your Gemfile:\r\n\r\n    gem 'qml'\r\n\r\nAnd then execute:\r\n\r\n    $ bundle install\r\n\r\nTo pass build options, use `bundle config`.\r\nFor example:\r\n\r\n    $ bundle config build.qml --with-libffi-dir=$(brew --prefix libffi) --with-qt-dir=$(brew --prefix qt5)\r\n\r\nThe configuration will be saved in `~/.bundle/config`.\r\n\r\n## Usage\r\n\r\n### Load QML file\r\n\r\nThe following code loads a QML file and shows an application window titled \"Hello, world!\".\r\n\r\n```ruby\r\nrequire 'qml'\r\n\r\nQML.application do |app|\r\n  app.load_path Pathname(__FILE__) + '../main.qml'\r\nend\r\n```\r\n\r\n```qml\r\n// main.qml\r\nimport QtQuick 2.2\r\nimport QtQuick.Controls 1.1\r\n\r\nApplicationWindow {\r\n    visible: true\r\n    width: 200\r\n    height: 100\r\n    title: \"Hello, world!\"\r\n}\r\n```\r\n\r\n### Use Ruby class in QML\r\n\r\nTo make your class available to QML, include `QML::Access` and call `register_to_qml`.\r\n\r\nBy including `QML::Access`, you can also define **properties and signals** in Ruby classes like in QML.\r\n\r\nProperties are used to bind data between QML and Ruby.\r\nSignals are used to provide the observer pattern-like notification from Ruby to QML.\r\n\r\n![Screenshot](https://raw.github.com/seanchas116/ruby-qml/master/examples/fizzbuzz/capture.png)\r\n\r\n```ruby\r\n# Ruby\r\nclass FizzBuzz\r\n  include QML::Access\r\n  register_to_qml under: \"Example\", version: \"1.0\"\r\n\r\n  property :input, '0'\r\n  property :result , ''\r\n  signal :inputWasFizzBuzz, []\r\n\r\n  on_changed :input do\r\n    i = input.to_i\r\n    self.result = case\r\n    when i % 15 == 0\r\n      inputWasFizzBuzz.emit\r\n      \"FizzBuzz\"\r\n    when i % 3 == 0\r\n      \"Fizz\"\r\n    when i % 5 == 0\r\n      \"Buzz\"\r\n    else\r\n      i.to_s\r\n    end\r\n  end\r\n\r\n  def quit\r\n    puts \"quitting...\"\r\n    QML.application.quit\r\n  end\r\nend\r\n```\r\n\r\n```qml\r\n// QML - main.qml\r\nimport QtQuick 2.2\r\nimport QtQuick.Controls 1.1\r\nimport QtQuick.Layouts 1.1\r\nimport Example 1.0\r\n\r\nApplicationWindow {\r\n    visible: true\r\n    width: 200\r\n    height: 200\r\n    title: \"FizzBuzz\"\r\n\r\n    ColumnLayout {\r\n        anchors.fill: parent\r\n        anchors.margins: 10\r\n        TextField {\r\n            placeholderText: \"Input\"\r\n            text: \"0\"\r\n            id: textField\r\n        }\r\n        Text {\r\n            id: text\r\n            text: fizzBuzz.result\r\n        }\r\n        Button {\r\n            text: 'Quit'\r\n            onClicked: fizzBuzz.quit()\r\n        }\r\n        Text {\r\n            id: lastFizzBuzz\r\n        }\r\n    }\r\n    FizzBuzz {\r\n        id: fizzBuzz\r\n        input: textField.text\r\n        onInputWasFizzBuzz: lastFizzBuzz.text = \"Last FizzBuzz: \" + textField.text\r\n    }\r\n}\r\n```\r\n\r\nYou can omit arguments of `register_to_qml` if they are obvious:\r\n\r\n```ruby\r\nmodule Example\r\n  VERSION = '1.0.0'\r\n\r\n  class FizzBuzz\r\n    include QML::Access\r\n    register_to_qml\r\n\r\n    ...\r\n  end\r\nend\r\n```\r\n\r\nIf the Ruby object is singleton, you can use the root context to make it available to QML.\r\nIn this case, you don't have to use `register_to_qml`.\r\n\r\n```ruby\r\nclass Foo\r\n  include QML::Access\r\n  def foo\r\n    puts \"foo\"\r\n  end\r\nend\r\n\r\nQML.application do |app|\r\n  app.context[:foo] = Foo.new\r\n  app.load_path Pathname(__FILE__) + '../main.qml'\r\nend\r\n```\r\n\r\n### Pass data to QML ListModels\r\n\r\nTo bind list data between QML ListView and Ruby, you can use ListModels.\r\n\r\n* `QML::Data::ListModel` - the base class for ruby-qml list models.\r\n\r\n* `QML::Data::ArrayModel` - provides a simple list model implementation using Array.\r\n\r\n* `QML::Data::QueryModel` - for databases (like ActiveRecord, Sequel or something)\r\n\r\nThis example uses `ArrayModel` to provide list data for a QML ListView.\r\nWhen the content of the ArrayModel is changed, the list view is also automatically updated.\r\n\r\n#### Examples\r\n\r\n* [Todo example](https://github.com/seanchas116/ruby-qml/tree/master/examples/todo_sequel)\r\n\r\n```ruby\r\n# Ruby\r\nclass TodoController\r\n  include QML::Access\r\n  register_to_qml under: \"Example\", version: \"1.0\"\r\n\r\n  property :model, QML::Data::ArrayModel.new(:title, :description, :due_date)\r\n\r\n  def add(title, description, due_date)\r\n    # Items of list models must be \"Hash-like\" (have #[] method to get columns)\r\n    item = {\r\n      title: title,\r\n      description: description,\r\n      due_date: due_date\r\n    }\r\n    p item\r\n    model << item\r\n  end\r\nend\r\n```\r\n\r\n```qml\r\n// QML\r\nListView {\r\n    model: todo.model\r\n    delegate: Text {\r\n        text: \"Title: \" + title + \",  Description: \" + description + \", Due date: \" + due_date\r\n    }\r\n}\r\nTodoController {\r\n  id: todo\r\n}\r\n```\r\n\r\n### Combile asynchronous operations\r\n\r\nIn QML, all UI-related operations are done synchronously in the event loop.\r\nTo set result of asynchronous operations to the UI, use `QML.later` or `QML::Dispatchable#later`.\r\n\r\n#### Examples\r\n\r\n* [Twitter Example](https://github.com/seanchas116/ruby-qml/tree/master/examples/twitter)\r\n\r\n```ruby\r\n# Ruby\r\nclass HeavyTaskController\r\n  # QML::Access includes QML::Dispathable\r\n  include QML::Access\r\n  register_to_qml under: \"Example\", version: \"1.0\"\r\n\r\n  property :result, ''\r\n\r\n  def set_result(result)\r\n    self.result = result\r\n  end\r\n\r\n  def start_heavy_task\r\n    Thread.new do\r\n      self.later.set_result do_heavy_task() # #set_result is called in the main thread in the next event loop\r\n      # or\r\n      QML.later do\r\n        set_result do_heavy_task()\r\n      end\r\n    end\r\n  end\r\nend\r\n```\r\n\r\n```qml\r\n// QML\r\nText {\r\n  text: controller.result\r\n}\r\nButton {\r\n  text: \"Start!!\"\r\n  onClicked: controller.start_heavy_task()\r\n}\r\nHeavyTaskController {\r\n  id: controller\r\n}\r\n```\r\n\r\n### Use Qt objects in Ruby\r\n\r\nIn ruby-qml, Qt objects (QObject-derived C++ objects and QML objects) can be accessed from Ruby via the meta-object system of Qt.\r\n\r\nYou can access:\r\n\r\n* Properties\r\n* Signals\r\n* Slots (as methods), Q_INVOKAVLE methods, QML methods\r\n\r\nYou cannot access:\r\n\r\n* Normal C++ member functions\r\n\r\nIf their names are camelCase in Qt, ruby-qml aliases them as underscore_case.\r\n\r\n```ruby\r\n# QML::Application is a wrapper for QApplication\r\napp = QML.application\r\n\r\n# set property\r\napp.applicationName = \"Test\"\r\napp.application_name = \"Test\" # aliased version\r\n\r\n# connect to signal\r\napp.aboutToQuit.connect do # \"about_to_quit\" is also OK\r\n  puts \"quitting...\"\r\nend\r\n\r\n# call method (slot)\r\napp.quit\r\n```\r\n\r\n### Value conversions\r\n\r\nThe following types are automatically converted between Ruby and QML:\r\n\r\n* Integer\r\n* Double\r\n* String\r\n* Time\r\n* Date\r\n* DateTime\r\n* Array\r\n* Hash\r\n* QML::Geometry::Point (QPoint, QPointF)\r\n* QML::Geometry::Size (QSize, QSizeF)\r\n* QML::Geometry::Rectangle (QRect, QRectF)\r\n* QML::QtObjectBase (Qt objects)\r\n* QML::Access\r\n* QML::Data::ListModel\r\n\r\n### Load and use Qt C++ plugins\r\n\r\n`PluginLoader` loads Qt C++ plugins.\r\nIt enables you to use your Qt C++ codes from Ruby easily.\r\n\r\n\r\n```c++\r\n// C++ - plugin example\r\nclass MyPlugin : public QObject\r\n{\r\n    Q_OBJECT\r\n    Q_PLUGIN_METADATA(IID \"org.myplugin.MyPlugin\")\r\nsignals:\r\n    void added(int value);\r\n\r\npublic slots:\r\n    int add(int x, int y) {\r\n        int result = x + y;\r\n        emit added(result);\r\n        return result;\r\n    }\r\n};\r\n```\r\n\r\n```ruby\r\n# Ruby\r\nplugin = QML::PluginLoader.new(directory, \"myplugin\").instance\r\n\r\nplugin.added.connect do |value|\r\n  puts \"added value: #{value}\"\r\nend\r\n\r\nplugin.add(1, 2) #=> 3\r\n```\r\n\r\n### Garbage collection\r\n\r\nTo support garbage collection of Qt objects used in ruby-qml,\r\n`#managed?` attribute of each Qt object wrappr determines its memory management status.\r\n\r\n#### Managed objects\r\n\r\n*Manged objects* are managed by Ruby and QML and garbage collected when no longer reachable.\r\nAll objects created inside QML and objects returned from C++ methods will be *managed* by default.\r\n\r\n#### Unmanaged objects\r\n\r\n*Unmanaged* objects are not managed and never garbage collected.\r\nObjects that have parents or that obtained from properties of other Qt objects will be *unmanaged* by default.\r\n\r\n#### Specify management status explicitly\r\n\r\nThe `#managed?` method returns whether the object is managed or not.\r\nThe `#prefer_managed` methods sets management status safely\r\n(e.g., objects that are created by QML will remain managed and objects that have parents will remain unmanaged).\r\n\r\n```ruby\r\nplugin = PluginLoader.new(path).instance\r\nobj = plugin.create_object\r\nobj.prefer_managed false\r\n```\r\n\r\n## Contributing\r\n\r\nContributions are welcome. When you are contributing to ruby-qml:\r\n\r\n1. Fork it ( http://github.com/seanchas116/ruby-qml/fork )\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Commit your changes (`git commit -am 'Add some feature'`)\r\n4. Write some tests if possible\r\n5. Push to the branch (`git push origin my-new-feature`)\r\n6. Create new Pull Request\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}