{"name":"ruby-qml","tagline":"A QML / Qt Quick bindings for Ruby","body":"ruby-qml [![Gem Version](https://badge.fury.io/rb/qml.svg)](http://badge.fury.io/rb/qml)\r\n================\r\n\r\nruby-qml is a QML / Qt Quick wrapper for Ruby.\r\nIt provides bindings between QML and Ruby and enables you to use Qt Quick-based GUI from Ruby.\r\n\r\n* [Documentation](http://rubydoc.info/github/seanchas116/ruby-qml/master/frames)\r\n* [Examples](https://github.com/seanchas116/ruby-qml/tree/master/examples)\r\n* [Changelog](https://github.com/seanchas116/ruby-qml/blob/master/changes.md)\r\n\r\n[![Dependency Status](https://gemnasium.com/seanchas116/ruby-qml.svg)](https://gemnasium.com/seanchas116/ruby-qml)\r\n[![Build Status](https://travis-ci.org/seanchas116/ruby-qml.svg?branch=master)](https://travis-ci.org/seanchas116/ruby-qml)\r\n[![Coverage Status](https://coveralls.io/repos/seanchas116/ruby-qml/badge.png?branch=master)](https://coveralls.io/r/seanchas116/ruby-qml?branch=master)\r\n[![Inline docs](http://inch-ci.org/github/seanchas116/ruby-qml.png?branch=master)](http://inch-ci.org/github/seanchas116/ruby-qml)\r\n\r\n## What you can do with ruby-qml\r\n\r\n* Develop desktop GUI applications only with Ruby and QML / JavaScript\r\n* Easily combine codes written in C++ and Qt with your Ruby code\r\n\r\n## Gallery\r\n\r\n[![Screenshot](https://raw.github.com/seanchas116/ruby-qml/master/examples/todo_sequel/capture.png)](https://github.com/seanchas116/ruby-qml/tree/master/examples/todo_sequel)\r\n\r\n[![Screenshot](https://raw.github.com/seanchas116/ruby-qml/master/examples/twitter/capture.png)](https://github.com/seanchas116/ruby-qml/tree/master/examples/twitter)\r\n\r\n## Installation\r\n\r\n### Requirements\r\n\r\n* **Ruby 2.1 or later**\r\n* **OS X or Linux**\r\n* Qt 5.2 or later\r\n\r\n### OS X with Homebrew\r\n\r\nTo install ruby-qml on OS X with Homebrew, run the following commands:\r\n\r\n    $ brew install qt5\r\n    $ gem install qml -- --with-qmake=$(brew --prefix qt5)/bin/qmake\r\n\r\nBoth libffi and Qt5 are keg-only in Homebrew, so you must specify their paths explicitly (or force linking).\r\n\r\nIf you use [official Qt installation](http://qt-project.org/downloads), for example:\r\n\r\n    $ gem install qml -- --with-qmake=$HOME/Qt/5.4/clang_64/bin/qmake\r\n\r\nThe Qt installation path (`$HOME/Qt/5.4/clang_64` in this example) depends on your Qt installation configuration and Qt version.\r\n\r\n### General (OSX and Linux)\r\n\r\n    $ gem install qml\r\n\r\n#### Options\r\n\r\n* `--with-qmake=[dir]`\r\n  * Qt qmake executable path (optional).\r\n\r\n### Use Gemfile\r\n\r\nAdd this line to your Gemfile:\r\n\r\n    gem 'qml'\r\n\r\nAnd then execute:\r\n\r\n    $ bundle install\r\n\r\nTo pass build options, use `bundle config`.\r\nFor example:\r\n\r\n    $ bundle config build.qml --with-qmake=$(brew --prefix qt5)/bin/qmake\r\n\r\nThe configuration will be saved in `~/.bundle/config`.\r\n\r\n## Usage\r\n\r\n### Load QML file\r\n\r\nThe following code loads a QML file and shows an application window titled \"Hello, world!\".\r\n\r\n```ruby\r\nrequire 'qml'\r\n\r\nQML.run do |app|\r\n  app.load_path Pathname(__FILE__) + '../main.qml'\r\nend\r\n```\r\n\r\n```qml\r\n// main.qml\r\nimport QtQuick 2.2\r\nimport QtQuick.Controls 1.1\r\n\r\nApplicationWindow {\r\n    visible: true\r\n    width: 200\r\n    height: 100\r\n    title: \"Hello, world!\"\r\n}\r\n```\r\n\r\n### Use Ruby class in QML\r\n\r\nTo make your class available to QML, include `QML::Access` and call `register_to_qml`.\r\n\r\nBy including `QML::Access`, you can also define **properties and signals** in Ruby classes like in QML.\r\n\r\nProperties are used to bind data between QML and Ruby.\r\nSignals are used to provide the observer pattern-like notification from Ruby to QML.\r\n\r\n![Screenshot](https://raw.github.com/seanchas116/ruby-qml/master/examples/fizzbuzz/capture.png)\r\n\r\n```ruby\r\n# Ruby\r\nclass FizzBuzz\r\n  include QML::Access\r\n  register_to_qml under: \"Example\", version: \"1.0\"\r\n\r\n  property(:input) { '0' }\r\n  property(:result) { '' }\r\n  signal :inputWasFizzBuzz, []\r\n\r\n  on_changed :input do\r\n    i = input.to_i\r\n    self.result = case\r\n    when i % 15 == 0\r\n      inputWasFizzBuzz.emit\r\n      \"FizzBuzz\"\r\n    when i % 3 == 0\r\n      \"Fizz\"\r\n    when i % 5 == 0\r\n      \"Buzz\"\r\n    else\r\n      i.to_s\r\n    end\r\n  end\r\n\r\n  def quit\r\n    puts \"quitting...\"\r\n    QML.application.quit\r\n  end\r\nend\r\n```\r\n\r\n```qml\r\n// QML - main.qml\r\nimport QtQuick 2.2\r\nimport QtQuick.Controls 1.1\r\nimport QtQuick.Layouts 1.1\r\nimport Example 1.0\r\n\r\nApplicationWindow {\r\n    visible: true\r\n    width: 200\r\n    height: 200\r\n    title: \"FizzBuzz\"\r\n\r\n    ColumnLayout {\r\n        anchors.fill: parent\r\n        anchors.margins: 10\r\n        TextField {\r\n            placeholderText: \"Input\"\r\n            text: \"0\"\r\n            id: textField\r\n        }\r\n        Text {\r\n            id: text\r\n            text: fizzBuzz.result\r\n        }\r\n        Button {\r\n            text: 'Quit'\r\n            onClicked: fizzBuzz.quit()\r\n        }\r\n        Text {\r\n            id: lastFizzBuzz\r\n        }\r\n    }\r\n    FizzBuzz {\r\n        id: fizzBuzz\r\n        input: textField.text\r\n        onInputWasFizzBuzz: lastFizzBuzz.text = \"Last FizzBuzz: \" + textField.text\r\n    }\r\n}\r\n```\r\n\r\nYou can omit arguments of `register_to_qml` if they are obvious:\r\n\r\n```ruby\r\nmodule Example\r\n  VERSION = '1.0.0'\r\n\r\n  class FizzBuzz\r\n    include QML::Access\r\n    register_to_qml\r\n\r\n    ...\r\n  end\r\nend\r\n```\r\n\r\n### Pass data to QML ListModels\r\n\r\nTo bind list data between QML ListView and Ruby, you can use ListModels.\r\n\r\n* `QML::ListModel` - the base class for ruby-qml list models.\r\n\r\n* `QML::ArrayModel` - provides a simple list model implementation using Array.\r\n\r\n* `QML::QueryModel` - for databases (like ActiveRecord, Sequel or something)\r\n\r\nThis example uses `ArrayModel` to provide list data for a QML ListView.\r\nWhen the content of the ArrayModel is changed, the list view is also automatically updated.\r\n\r\n#### Examples\r\n\r\n* [Todo example](https://github.com/seanchas116/ruby-qml/tree/master/examples/todo_sequel)\r\n\r\n```ruby\r\n# Ruby\r\nclass TodoController\r\n  include QML::Access\r\n  register_to_qml under: \"Example\", version: \"1.0\"\r\n\r\n  property(:model) { QML::ArrayModel.new(:title, :description, :due_date) }\r\n\r\n  def add(title, description, due_date)\r\n    # Items of list models must be \"Hash-like\" (have #[] method to get columns)\r\n    item = {\r\n      title: title,\r\n      description: description,\r\n      due_date: due_date\r\n    }\r\n    model << item\r\n  end\r\nend\r\n```\r\n\r\n```qml\r\n// QML\r\nListView {\r\n    model: todo.model\r\n    delegate: Text {\r\n        text: \"Title: \" + title + \",  Description: \" + description + \", Due date: \" + due_date\r\n    }\r\n}\r\nTodoController {\r\n  id: todo\r\n}\r\n```\r\n\r\n### Combile asynchronous operations\r\n\r\nIn QML, all UI-related operations are done synchronously in the event loop.\r\nTo set result of asynchronous operations to the UI, use `QML.next_tick`.\r\n\r\n#### Examples\r\n\r\n* [Twitter Example](https://github.com/seanchas116/ruby-qml/tree/master/examples/twitter)\r\n\r\n```ruby\r\n# Ruby\r\nclass HeavyTaskController\r\n  include QML::Access\r\n  register_to_qml under: \"Example\", version: \"1.0\"\r\n\r\n  property(:result) { '' }\r\n\r\n  def set_result(result)\r\n    self.result = result\r\n  end\r\n\r\n  def start_heavy_task\r\n    Thread.new do\r\n      QML.next_tick do\r\n        set_result do_heavy_task()\r\n      end\r\n    end\r\n  end\r\nend\r\n```\r\n\r\n```qml\r\n// QML\r\nText {\r\n  text: controller.result\r\n}\r\nButton {\r\n  text: \"Start!!\"\r\n  onClicked: controller.start_heavy_task()\r\n}\r\nHeavyTaskController {\r\n  id: controller\r\n}\r\n```\r\n\r\n### Value conversions between Ruby and QML JavaScript\r\n\r\n\r\n#### Ruby to QML\r\n\r\n|Ruby            |QML/JavaScript                  |\r\n|----------------|--------------------------------|\r\n|nil             |null                            |\r\n|true/false      |boolean                         |\r\n|Numeric         |number                          |\r\n|String/Symbol   |string                          |\r\n|Array           |Array                           |\r\n|Hash            |plain Object                    |\r\n|Proc            |Function                        |\r\n|Time            |Date                            |\r\n|QML::Access     |Object(QObject derived)         |\r\n|QML::ListModel  |Object(QAbstractListModel)      |\r\n\r\nYou can customize this by implementing `#to_qml` method.\r\n\r\n#### QML to Ruby\r\n\r\n|QML/JavaScript                  |Ruby            |\r\n|--------------------------------|----------------|\r\n|null/undefined                  |nil             |\r\n|boolean                         |true/false      |\r\n|number                          |Float           |\r\n|string                          |String          |\r\n|Array                           |QML::JSArray    |\r\n|Function                        |QML::JSFunction |\r\n|Object                          |QML::JSObject   |\r\n|Object wrapping QML::Access     |QML::JSWrapper  |\r\n\r\nYou can convert Objects further through QML::JSObject methods.\r\n\r\n\r\n### QML::JSObject usage\r\n\r\n`QML::JSObject` is the wrapper class for JavaScript objects.\r\n\r\n```ruby\r\nobj = QML.engine.evaluate <<-JS\r\n  ({\r\n    value: 1,\r\n    add: function(d) {\r\n      this.value += d;\r\n    }\r\n  })\r\nJS\r\n\r\n# Getter\r\nobj.value #=> 1\r\n\r\n# Setter\r\nobj.value = 2\r\nobj.vaue #=> 2\r\n\r\n# Call method if the property is a function\r\nobj.add(10)\r\nobj.value #=> 11\r\n\r\n# Subscription\r\nobj[:value] #=> 11\r\nobj[:add] #=> #<QML::JSFunction:...>\r\n```\r\n\r\n### Load and use Qt C++ plugins\r\n\r\n`PluginLoader` loads Qt C++ plugins.\r\nIt enables you to use your Qt C++ codes from Ruby easily.\r\n\r\n```c++\r\n// C++ - plugin example\r\nclass MyPlugin : public QObject\r\n{\r\n    Q_OBJECT\r\n    Q_PLUGIN_METADATA(IID \"org.myplugin.MyPlugin\")\r\nsignals:\r\n    void added(int value);\r\n\r\npublic slots:\r\n    int add(int x, int y) {\r\n        int result = x + y;\r\n        emit added(result);\r\n        return result;\r\n    }\r\n};\r\n```\r\n\r\n```ruby\r\n# Ruby\r\n\r\n# The instance will be a `QML::JSObject` which represents the plugin Qt object\r\nplugin = QML::PluginLoader.new(directory, \"myplugin\").instance\r\n\r\n# Connect to signal (see http://doc.qt.io/qt-5/qtqml-syntax-signals.html#connecting-signals-to-methods-and-signals)\r\nplugin[:added].connect do |value|\r\n  puts \"added value: #{value}\"\r\nend\r\n\r\nplugin.add(1, 2) #=> 3\r\n```\r\n\r\n### Use with EventMachine\r\n\r\nYou can use [EventMachine](https://github.com/eventmachine/eventmachine) with ruby-qml.\r\nIt is more powerful than the default ruby-qml event loop.\r\n\r\nInstead of using `QML.run`, start an EventMachine event loop by `EM.run` and\r\nprocess QML events periodically by `QML::Application#process_events`.\r\n\r\n```ruby\r\nrequire 'qml'\r\nrequire 'eventmachine'\r\n\r\nEM.run do\r\n  QML.init\r\n  EM.add_periodic_timer(0.01) { QML.application.process_events }\r\n  QML.application.load_path(Pathname.pwd + 'main.qml')\r\nend\r\n```\r\n\r\nYou can also use [em-synchrony](https://github.com/igrigorik/em-synchrony) to\r\nwrite callback-free asynchronous operation for ruby-qml.\r\n\r\n```ruby\r\nrequire 'qml'\r\nrequire 'eventmachine'\r\nrequire 'em-synchrony'\r\nrequire 'em-http-request'\r\n\r\nclass Controller\r\n  include QML::Access\r\n  property(:result) { '' }\r\n\r\n  def get\r\n    EM.synchrony do\r\n      content = EM::Synchrony.sync EM::HttpRequest.new('http://www.example.com/').get\r\n      self.result = content.response\r\n    end\r\n  end\r\n\r\n  def quit\r\n    EM.stop\r\n  end\r\n\r\n  register_to_qml under: 'Example', version: '0.1'\r\nend\r\n\r\nEM.run do\r\n  QML.init\r\n  EM.add_periodic_timer(0.01) { QML.application.process_events }\r\n  QML.application.load_path(Pathname.pwd + 'main.qml')\r\nend\r\n```\r\n\r\n## Contributing\r\n\r\n### Init submodules\r\n\r\n```\r\n$ git submodule init\r\n$ git submodule update\r\n```\r\n\r\n### Install dependencies\r\n\r\n```\r\n$ bundle install\r\n```\r\n\r\n### Build native extension\r\n\r\nBefore running ruby-qml in development, the native extension of ruby-qml needs to have been built.\r\nTo build it, run the following commands:\r\n\r\n```\r\n$ cd ext/qml\r\n$ bundle exec ruby extconf.rb --with-qmake=/path/to/qmake\r\n$ make -j4\r\n```\r\n\r\n### Run tests\r\n\r\nTests for ruby-qml is written in RSpec. To run tests, do:\r\n\r\n```\r\n$ bundle exec rspec\r\n```\r\n\r\n### Run examples\r\n\r\n```\r\n$ bundle exec ruby examples/fizzbuzz/fizzbuzz.rb\r\n```\r\n\r\n### Send pull requests\r\n\r\n1. Fork it ( http://github.com/seanchas116/ruby-qml/fork )\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Commit your changes (`git commit -am 'Add some feature'`)\r\n4. Write some tests\r\n5. Push to the branch (`git push origin my-new-feature`)\r\n6. Create new Pull Request\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}